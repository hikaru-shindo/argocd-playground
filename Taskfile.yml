# https://taskfile.dev

version: '3'

vars:
  cluster_name: gitops-test

tasks:
  default:
    cmds:
      - task: cluster:status

  cluster:create:
    vars:
      cpus: '{{default "4" .cpus}}'
      disk_size: '{{default "20000mb" .disk_size}}'
      enable_argo: '{{default "true" .enable_argo}}'
      enable_flux: '{{default "true" .enable_flux}}'
      flux_version: '{{default "v2.2.3" .flux_version}}'
      scmm_version: '{{default "2.48.3" .scmm_version}}'
      kubernetes_version: '{{default "1.29.2" .kubernetes_version}}'
    preconditions:
      - sh: minikube version
        msg: minikube is not installed
      - sh: kubectl version --client
        msg: kubectl is not installed
      - sh: helm version
        msg: Helm is not installed
    desc: Create a test cluster
    status:
      - minikube status -p {{.cluster_name}}
    cmds:
      - cmd: |-
          echo "ArgoCD: see argocd/argocd/argocd/Chart.yaml (enabled: {{.enable_argo}})"
          echo "FluxCD: {{.flux_version}} (enabled: {{.enable_flux}}) "
          echo "SCM Manager: {{.scmm_version}}"
        silent: true
      - minikube start -p {{.cluster_name}} --cpus={{.cpus}} --disk-size='{{.disk_size}}' --kubernetes-version={{.kubernetes_version}}
      - task: namespaces:create
      - task: scm:install
        vars:
          version: '{{.scmm_version}}'
      - task: flux:install
        vars:
          enabled: '{{.enable_flux}}'
          version: '{{.flux_version}}'
      - task: argo:install
        vars:
          enabled: '{{.enable_argo}}'

  cluster:delete:
    desc: Delete a test cluster
    prompt: This will destroy your {{.cluster_name}} playground. Are you sure?
    cmds:
      - minikube delete -p {{.cluster_name}}

  cluster:status:
    desc: Show status of a test cluster
    cmds:
      - minikube status -p {{.cluster_name}} || true

  namespaces:create:
    internal: true
    desc: Create initial team namespaces
    cmds:
      - kubectl create namespace team-a-production
      - kubectl create namespace team-a-staging
      - kubectl create namespace team-b-production
      - kubectl create namespace team-b-staging

  flux:install:
    internal: true
    desc: Install flux to test cluster
    vars:
      enabled: '{{default "true" .enabled}}'
      version: '{{default "latest" .version}}'
    status:
      - 'test "{{.enabled}}" != "true"'
    cmds:
      - kubectl apply --context {{.cluster_name}} -f https://github.com/fluxcd/flux2/releases/download/{{ .version }}/install.yaml
      - kubectl get deploy --context {{.cluster_name}} --output name -n flux-system | xargs -n1 -t kubectl rollout status --context {{.cluster_name}} -n flux-system
    
  argo:install:
    internal: true
    desc: Install argocd to test cluster
    dir: argocd/argocd
    vars:
      enabled: '{{default "true" .enabled}}'
    status:
      - '[ "{{.enabled}}" != "true" ] || helm status --kube-context {{.cluster_name}} -n argocd argocd'
    cmds:
      - helm dep build argocd/
      - helm upgrade --kube-context {{.cluster_name}} --install --wait --namespace argocd --create-namespace argocd argocd/
      - task: argo:password

  argo:init:
    desc: Initialise argocd for usage
    dir: argocd/argocd
    preconditions:
      - sh: helm status -n argocd argocd --kube-context {{.cluster_name}}
        msg: ArgoCD is not currently installed on the test cluster {{.cluster_name}}
    cmds:
      - kubectl apply --context {{ .cluster_name }} -f projects/argocd.yaml
      - kubectl apply --context {{ .cluster_name }} -f applications/bootstrap.yaml
      - for:
        - '{"repo": "argocd", "description": "Repository for ArgoCD bootstrapping"}'
        - '{"repo": "cluster-addons", "description": "Repository for an infrastructure/plattform team"}'
        - '{"repo": "team-a", "description": "Repository for an imaginary team A"}'
        - '{"repo": "team-b", "description": "Repository for an imaginary team A"}'
        task: scm:create-repo
        vars:
          repo:  '{{(.ITEM | mustFromJson).repo | mustToJson}}'
          description:  '{{(.ITEM | mustFromJson).repo | mustToJson}}'
      - for:
        - '{"repo": "gitops/argocd", "source_path": "argocd/argocd"}'
        - '{"repo": "gitops/cluster-addons", "source_path": "argocd/cluster-addons"}'
        - '{"repo": "gitops/team-a", "source_path": "argocd/team-a"}'
        - '{"repo": "gitops/team-b", "source_path": "argocd/team-b"}'
        task: scm:init-repo-from-source
        vars:
          repo:  '{{(.ITEM | mustFromJson).repo | mustToJson}}'
          source_path:  '{{(.ITEM | mustFromJson).source_path | mustToJson}}'

  flux:init:
    desc: Initialise flux2 for usage
    preconditions:
      - sh: kubectl --context {{ .cluster_name }} get namespace flux-system
        msg: FluxCD is not currently installed on the test cluster {{.cluster_name}}
    cmds:
      - cmd: echo "Not yet implemented, sorry ðŸ˜¢ ..."
        silent: true

  argo:forward:
    vars:
      port: '{{default "8080" .port}}'
    desc: Forward the argocd UI to a local port
    cmds:
      - kubectl port-forward service/argocd-server --context {{ .cluster_name }} -n argocd {{.port}}:443

  argo:password:
    desc: Get the initial admin password for argocd
    cmds:
      - echo "Your initial ArgoCD admin password is:"
      - kubectl get secret argocd-initial-admin-secret --context {{ .cluster_name }} -n argocd -o jsonpath="{.data.password}" | base64 -d | xargs echo
    silent: true

  scm:install:
    internal: true
    vars:
      version: '{{default "2.48.3" .version}}'
    dir: scm-manager
    desc: Install gitea to test cluster
    cmds:
      - helm repo add scm-manager https://packages.scm-manager.org/repository/helm-v2-releases/
      - helm repo update
      - helm upgrade --kube-context {{.cluster_name}} --version {{.version}} --install --wait --namespace scm-manager --create-namespace scm-manager --values values.yaml scm-manager/scm-manager
      - for:
        - '{"plugin": "scm-review-plugin"}'
        - '{"plugin": "scm-code-editor-plugin"}'
        - '{"plugin": "scm-editor-plugin"}'
        - '{"plugin": "scm-activity-plugin"}'
        - '{"plugin": "scm-el-plugin"}'
        - '{"plugin": "scm-readme-plugin"}'
        - '{"plugin": "scm-webhook-plugin", "restart": "true"}'
        task: scm:install-plugin
        vars:
          plugin:  '{{(.ITEM | mustFromJson).plugin | mustToJson}}'
          restart:  '{{(.ITEM | mustFromJson).restart | mustToJson}}'

  scm:create-repo:
    internal: true
    desc: "Create a SCM repository"
    vars:
      repo: '{{default "" .repo}}'
      description: '{{default "" .description}}'
      namespace: '{{default "gitops" .namespace}}'
    cmds:
      - echo "Creating repository {{.namespace}}/{{.repo}} ..."
      - |- 
        kubectl run -it --rm --restart=Never --image=curlimages/curl repo-creator-{{.repo}} -- -i -s -o /dev/null -L --write-out '%{http_code}' \
        -X POST -H "Content-Type: application/vnd.scmm-repository+json;v=2" \
        --data "{\"name\":\"{{.repo}}\",\"namespace\":\"{{.namespace}}\",\"type\":\"git\",\"contact\":\"admin@mail.de\",\"description\":\"{{.description}}\",\"contextEntries\":{},\"_links\":{}}" \
        http://gitops:gitops@scm-manager.scm-manager.svc.cluster.local/scm/api/v2/repositories
    silent: true

  scm:install-plugin:
    internal: true
    desc: Install a SCM plugin
    vars:
      plugin: '{{default "" .plugin}}'
      restart: '{{default "false" .restart}}'
    cmds:
      - echo "Installing plugin {{.plugin}}{{if eq .restart "true"}} and restarting{{end}} ..."
      - |-
        kubectl run -it --rm --restart=Never --image=curlimages/curl plugin-installer-{{.plugin}} -- -i -s -o /dev/null -L --write-out '%{http_code}' \
        -X POST -H "accept: */*" --data "" \
        http://gitops:gitops@scm-manager.scm-manager.svc.cluster.local/scm/api/v2/plugins/available/{{.plugin}}/install{{if eq .restart "true"}}?restart=true{{end}}
    silent: true

  scm:init-repo-from-source:
    internal: true
    vars:
      repo: '{{default "" .repo}}'
      source_path: '{{default "" .source_path}}'
      random_id:
        sh: cat /dev/urandom | LC_ALL=C tr -dc 'a-f0-9' | fold -w 8 | head -n 1
    desc: Initialize a SCM repository from local source
   # silent: true
    cmds:
      - kubectl run --context {{ .cluster_name }} --image bitnami/git --command --restart=Never git-{{.random_id}} -- sleep 3600
      - defer: kubectl delete pod git-{{.random_id}} --context {{ .cluster_name }}
      - kubectl wait --context {{ .cluster_name }} --for=condition=ready pod git-{{.random_id}}
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- git config --global user.email "scm@example.com"
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- git config --global user.name "GitOps"
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- git config --global init.defaultBranch main
      - kubectl cp {{.source_path}} git-{{.random_id}}:/source
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- git clone http://gitops:gitops@scm-manager.scm-manager.svc.cluster.local/scm/repo/{{.repo}} /repo
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- sh -c 'cp -r /source/* /repo'
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- git -C /repo add . 
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- git -C /repo commit -m "Initialise {{ .repo }}" 
      - kubectl exec --context {{ .cluster_name }} git-{{.random_id}} -- git -C /repo push

  scm:forward:
    vars:
      port: '{{default "8081" .port}}'
    desc: Forward the gitea UI to a local port
    cmds:
      - kubectl port-forward service/scm-manager --context {{ .cluster_name }} -n scm-manager {{.port}}:80
